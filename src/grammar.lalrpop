use crate::language_definition::{
    TokenType, 
    ReservedWordType::*, 
    SymbolType::*,
    ExpressionType::*,
    Relop::*,
    Op::*,
    MulOp::*,
};

grammar;

pub file: () = {
    program,
};

// PROGRAM -> (STATEMENT | FUNCLIST)?
pub program: () = {
    statement,
    funclist,
};

// FUNCLIST -> FUNCDEFFUNCLIST | FUNCDEF
pub funclist: () = {
    funcdef funclist,
    funcdef,
};

// FUNCDEF -> def ident(PARAMLIST){STATELIST }
pub funcdef: () = {
    def_word ident oparenth paramlist cparenth ocurly statelist ccurly,
    def_word ident oparenth cparenth ocurly statelist ccurly
};

// PARAMLIST -> ((int | float | string) ident, PARAMLIST | (int | float | string) ident)?
pub paramlist: () = {
    vartype ident comma paramlist,
    vartype ident,
};

// STATEMENT -> (VARDECL; | ATRIBSTAT; |  PRINTSTAT; | READSTAT; | RETURNSTAT; | IFSTAT | FORSTAT | {STATELIST } | break; |;)
pub statement: () = {
    vardecl semicolon,
    attribstat semicolon,
    printstat semicolon,
    readstat semicolon,
    returnstat semicolon,
    ifstat,
    forstat,
    ocurly statelist ccurly,
    break_word semicolon,
    semicolon,
};
// TO-DO: VARDECL -> (int | float | string) ident ([int_constant])*
pub vardecl: () = {
    vartype ident,
    vardecl obrack int_constant cbrack,
};

// ATRIBSTAT -> LVALUE = (EXPRESSION | ALLOCEXPRESSION | FUNCCALL)
pub attribstat: () = {
    lvalue attrib expression,
    lvalue attrib allocexpression,
    lvalue attrib funccall,
};

// FUNCCALL -> ident(PARAMLISTCALL)
pub funccall: () = {
    ident oparenth paramlistcall cparenth,
};

// PARAMLISTCALL -> (ident, PARAMLISTCALL | ident)?
pub paramlistcall: () = {
    ident comma paramlistcall,
    ident,
};

// PRINTSTAT -> print EXPRESSION
pub printstat: () = {
    print_word expression,
};

// READSTAT -> read LVALUE
pub readstat: () = {
    read_word lvalue,
}

// RETURNSTAT -> return
pub returnstat: () = {
    return_word,
    return_word expression,
};

// IFSTAT -> if (EXPRESSION) STATEMENT (else STATEMENT)?
pub ifstat: () = {
    if_word oparenth expression cparenth ocurly statelist ccurly,
    if_word oparenth expression cparenth ocurly statelist ccurly else_word ocurly statelist ccurly,
};

// FORSTAT -> for(ATRIBSTAT; EXPRESSION; ATRIBSTAT) STATEMENT
pub forstat: () = {
    for_word oparenth attribstat semicolon expression semicolon attribstat cparenth statement,
};

// STATELIST -> STATEMENT (STATELIST)?
pub statelist: () = {
    statement,
    statement statelist,
};

// TO-DO: ALLOCEXPRESSION -> new (int | float | string) ([NUMEXPRESSION])+
pub allocexpression: () = {
    new_word    vartype,
    allocexpression obrack numexpression cbrack,
};

// EXPRESSION -> NUMEXPRESSION ((< | > | <= | >= | == | ! =) NUMEXPRESSION)?
pub expression: () = {
    numexpression,
    expression relop numexpression,
};

// NUMEXPRESSION -> TERM ((+ |-) TERM)*
pub numexpression: Vec<TokenType> = {
    term => vec![],
    numexpression addop term => vec![],
};

// TERM -> UNARYEXPR((* | / | %) UNARYEXPR)*
pub term: () = {
    unaryexpr,
    term mulop unaryexpr,
};

// UNARYEXPR -> ((+ | -))? FACTOR
pub unaryexpr: () = {
    factor,
    addop factor
};

// FACTOR -> (int_constant | float_constant | string_constant | LVALUE |(NUMEXPRESSION))
pub factor: Vec<TokenType> = {
    <i:int_constant> => vec![i],
    <i:float_constant> => vec![i],
    <i:string_constant> => vec![i],
    <i:lvalue> => i,
    <i0:oparenth> <i1:numexpression> <i2:cparenth> => vec![i0].extend(i1).push(i2),
};

// TO-DO: LVALUE -> ident([NUMEXPRESSION])*
pub lvalue: Vec<TokenType> = {
    <i:ident> => vec![i],
    <i0:lvalue> <i1:obrack> <i2:numexpression> <i3:cbrack> => i0.push(i1).append(i2).push(i3),
};

pub ident: TokenType = {
    <value:r"[a-zA-Z][a-zA-Z0-9]*"> => TokenType::Expression(Ident(value.to_string())),
};

pub int_constant: TokenType = {
    <value:r"\d+"> => TokenType::Expression(IntConst(value.to_string())),
}

pub float_constant: TokenType = {
    <value:r"\d+\.\d*"> => TokenType::Expression(FloatConst(value.to_string())),
}

pub string_constant: TokenType = {
    <value:r#"".*""#> => TokenType::Expression(StrConst(value.to_string())),
}

pub semicolon: TokenType = {
    ";" => TokenType::Symbol(Semicolon),
};

pub comma: TokenType = {
    "," => TokenType::Symbol(Comma),
};

pub addop: TokenType = {
    "+" => TokenType::Expression(Op(Add)),
    "-" => TokenType::Expression(Op(Sub)),
};

pub mulop: TokenType = {
    "*" => TokenType::Expression(MulOp(Mul)),
    "/" => TokenType::Expression(MulOp(Div)),
    "%" => TokenType::Expression(MulOp(Mod)),
};

pub relop: TokenType = {
    "==" => TokenType::Expression(Relop(Equal)),
    "<>" => TokenType::Expression(Relop(Diff)),
    "<" => TokenType::Expression(Relop(Less)),
    ">" => TokenType::Expression(Relop(Greater)),
    "<=" => TokenType::Expression(Relop(EqualLess)),
    ">=" => TokenType::Expression(Relop(EqualGreater)),
};

pub vartype: TokenType = {
    "int" => TokenType::ReservedWord(Int),
    "string" => TokenType::ReservedWord(String),
    "float" => TokenType::ReservedWord(Float),
}

pub attrib: TokenType = {
    "=" => TokenType::Symbol(Attrib),
}

pub oparenth: TokenType = {
    "(" => TokenType::Symbol(OParenth),
} 
pub cparenth: TokenType = {
    ")" => TokenType::Symbol(CParenth),
} 
pub obrack: TokenType = {
    "[" => TokenType::Symbol(OBrack),
} 
pub cbrack: TokenType = {
    "]" => TokenType::Symbol(CBrack),
}
pub ocurly: TokenType = {
    "{" => TokenType::Symbol(OCurly),
}
pub ccurly: TokenType = {
    "}" => TokenType::Symbol(CCurly),
}

pub def_word: TokenType = {
    "def" => TokenType::ReservedWord(Def),
}

pub for_word: TokenType = {
    "for" => TokenType::ReservedWord(For)
}

pub if_word: TokenType = {
    "if" => TokenType::ReservedWord(If)
}

pub else_word: TokenType = {
    "else" => TokenType::ReservedWord(Else)
}

pub return_word: TokenType = {
    "return" => TokenType::ReservedWord(Return)
}

pub break_word: TokenType = {
    "break" => TokenType::ReservedWord(Break)
}

pub new_word: TokenType = {
    "new" => TokenType::ReservedWord(New)
}

pub print_word: TokenType = {
    "print" => TokenType::ReservedWord(Print)
}

pub read_word: TokenType = {
    "read" => TokenType::ReservedWord(Read)
}