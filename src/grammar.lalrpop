use crate::language_definition::{TokenType, ReservedWord, Symbol, Expression};

grammar;

pub file: () = {
    program,
};

// PROGRAM -> (STATEMENT | FUNCLIST)?
pub program: () = {
    statement,
    funclist,
};

// FUNCLIST -> FUNCDEFFUNCLIST | FUNCDEF
pub funclist: () = {
    funcdef funclist,
    funcdef,
};

// FUNCDEF -> def ident(PARAMLIST){STATELIST }
pub funcdef: () = {
    def_word ident oparenth paramlist cparenth ocurly statelist ccurly,
    def_word ident oparenth cparenth ocurly statelist ccurly
};

// PARAMLIST -> ((int | float | string) ident, PARAMLIST | (int | float | string) ident)?
pub paramlist: () = {
    vartype ident comma paramlist,
    vartype ident,
};

// STATEMENT -> (VARDECL; | ATRIBSTAT; |  PRINTSTAT; | READSTAT; | RETURNSTAT; | IFSTAT | FORSTAT | {STATELIST } | break; |;)
pub statement: () = {
    vardecl semicolon,
    attribstat semicolon,
    printstat semicolon,
    readstat semicolon,
    returnstat semicolon,
    ifstat,
    forstat,
    ocurly statelist ccurly,
    break_word semicolon,
    semicolon,
};
// TO-DO: VARDECL -> (int | float | string) ident ([int_constant])*
pub vardecl: () = {
    vartype ident,
    vardecl obrack int_constant cbrack,
};

// ATRIBSTAT -> LVALUE = (EXPRESSION | ALLOCEXPRESSION | FUNCCALL)
pub attribstat: () = {
    lvalue attrib expression,
    lvalue attrib allocexpression,
    lvalue attrib funccall,
};

// FUNCCALL -> ident(PARAMLISTCALL)
pub funccall: () = {
    ident oparenth paramlistcall cparenth,
};

// PARAMLISTCALL -> (ident, PARAMLISTCALL | ident)?
pub paramlistcall: () = {
    ident comma paramlistcall,
    ident,
};

// PRINTSTAT -> print EXPRESSION
pub printstat: () = {
    print_word expression,
};

// READSTAT -> read LVALUE
pub readstat: () = {
    read_word lvalue,
}

// RETURNSTAT -> return
pub returnstat: () = {
    return_word,
    return_word expression,
};

// IFSTAT -> if (EXPRESSION) STATEMENT (else STATEMENT)?
pub ifstat: () = {
    if_word oparenth expression cparenth ocurly statelist ccurly,
    if_word oparenth expression cparenth ocurly statelist ccurly else_word ocurly statelist ccurly,
};

// FORSTAT -> for(ATRIBSTAT; EXPRESSION; ATRIBSTAT) STATEMENT
pub forstat: () = {
    for_word oparenth attribstat semicolon expression semicolon attribstat cparenth statement,
};

// STATELIST -> STATEMENT (STATELIST)?
pub statelist: () = {
    statement,
    statement statelist,
};

// TO-DO: ALLOCEXPRESSION -> new (int | float | string) ([NUMEXPRESSION])+
pub allocexpression: () = {
    new_word    vartype,
    allocexpression obrack numexpression cbrack,
};

// EXPRESSION -> NUMEXPRESSION ((< | > | <= | >= | == | ! =) NUMEXPRESSION)?
pub expression: () = {
    numexpression,
    expression relop numexpression,
};

// NUMEXPRESSION -> TERM ((+ |-) TERM)*
pub numexpression: () = {
    term,
    numexpression addop term,
};

// TERM -> UNARYEXPR((* | / | %) UNARYEXPR)*
pub term: () = {
    unaryexpr,
    term mulop unaryexpr,
};

// UNARYEXPR -> ((+ | -))? FACTOR
pub unaryexpr: () = {
    factor,
    addop factor
};

// FACTOR -> (int_constant | float_constant | string_constant | LVALUE |(NUMEXPRESSION))
pub factor: () = {
    int_constant,
    float_constant,
    string_constant,
    lvalue,
    oparenth numexpression cparenth,
};

// TO-DO: LVALUE -> ident([NUMEXPRESSION])*
pub lvalue: () = {
    ident,
    lvalue obrack numexpression cbrack,
};

pub ident: TokenType::Expression = {
    <value:r"[a-zA-Z][a-zA-Z0-9]*"> => TokenType::Expression::Ident(value.to_string()),
};

pub int_constant: TokenType::Expression = {
    <value:r"\d+"> => TokenType::Expression::IntConst(value.to_string())
}

pub float_constant: TokenType::Expression = {
    <value:r"\d+\.\d*"> => TokenType::Expression::FloatConst(value.to_string())
}

pub string_constant: TokenType::Expression = {
    <value:r#"".*""#> => TokenType::Expression::StrConst(value.to_string()),
}

pub semicolon: Symbol = {
    ";" => Symbol::Semicolon,
};

pub comma: Symbol = {
    "," => Symbol::Comma,
};

pub addop: TokenType::Expression = {
    "+" => TokenType::Expression::Op("+".to_string()),
    "-" => TokenType::Expression::Op("-".to_string()),
};

pub mulop: TokenType::Expression = {
    "*" => TokenType::Expression::Op("*".to_string()),
    "/" => TokenType::Expression::Op("/".to_string()),
};

pub relop: TokenType::Expression = {
    "==" => TokenType::Expression::Relop("==".to_string()),
    "<>" => TokenType::Expression::Relop("<>".to_string()),
    "<" => TokenType::Expression::Relop("<".to_string()),
    ">" => TokenType::Expression::Relop(">".to_string()),
    "<=" => TokenType::Expression::Relop("<=".to_string()),
    ">=" => TokenType::Expression::Relop(">=".to_string()),
};

pub vartype: ReservedWord = {
    "int" => ReservedWord::Int,
    "string" => ReservedWord::String,
    "float" => ReservedWord::Float,
}

pub attrib: Symbol = {
    "=" => Symbol::Attrib,
}

pub oparenth: Symbol = {
    "(" => Symbol::OParenth,
} 
pub cparenth: Symbol = {
    ")" => Symbol::CParenth,
} 
pub obrack: Symbol = {
    "[" => Symbol::OBrack,
} 
pub cbrack: Symbol = {
    "]" => Symbol::CBrack,
}
pub ocurly: Symbol = {
    "{" => Symbol::OCurly,
}
pub ccurly: Symbol = {
    "}" => Symbol::CCurly,
}

pub def_word: ReservedWord = {
    "def" => ReservedWord::Def,
}

pub for_word: ReservedWord = {
    "for" => ReservedWord::For
}

pub if_word: ReservedWord = {
    "if" => ReservedWord::If
}

pub else_word: ReservedWord = {
    "else" => ReservedWord::Else
}

pub return_word: ReservedWord = {
    "return" => ReservedWord::Return
}

pub break_word: ReservedWord = {
    "break" => ReservedWord::Break
}

pub new_word: ReservedWord = {
    "new" => ReservedWord::New
}

pub print_word: ReservedWord = {
    "print" => ReservedWord::Print
}

pub read_word: ReservedWord = {
    "read" => ReservedWord::Read
}